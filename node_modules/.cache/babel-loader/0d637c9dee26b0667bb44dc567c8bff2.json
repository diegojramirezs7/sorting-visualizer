{"ast":null,"code":"// mergesort = (list) => {\n// \tvar m = 1;\n// \tvar right;\n// \tvar left;\n// \tvar sorted; \n// \tvar maxIndex;\n// \tvar auxArray; \n// \twhile (m < n){\n// \t\tvar i = 0;\n// \t\twhile(i< n - m){\n// \t\t\tleft = list.slice(i, i+m-1);\n// \t\t\tmaxIndex = Math.min(i+2*m-1, n-1)\n// \t\t\tright = list.slice(i+m, maxIndex);\n// \t\t\tsorted = [];\n// \t\t\tauxArray = [];\n// \t\t\twhile(left.right && right.length){\n// \t\t\t\tif(left[0].value <= right[0].value){\n// \t\t\t\t\tsorted.push(left.shift());\n// \t\t\t\t}else{\n// \t\t\t\t\tsorted.push(right.shift());\n// \t\t\t\t}\n// \t\t\t}\n// \t\t\twhile(left.length){\n// \t\t\t\tsorted.push(left.shift());\n// \t\t\t}\n// \t\t\twhile(right.length){\n// \t\t\t\tsorted.push(right.shift());\n// \t\t\t}\n// \t\t\tvar x = list.slice(0, i);\n// \t\t\tvar y = list.slice(maxIndex, list.length);\n// \t\t\tauxArray = x.concat(sorted, y);\n// \t\t\ti = i + 2*m\n// \t\t}\n// \t\tm = m * 2;\n// \t}\n// \tthis.setState({array: auxArray});\n// }\n// heapify = (list) => {\n// \tvar j; \n// \tfor (var i = 0; i<list.length; i++){\n// \t\t//if child is bigger than parent\n// \t\tif(list[i].value > list[Math.floor((i-1)/2)].value){\n// \t\t\tj = i;\n// \t\t\t//swap child and parent until parent is smaller\n// \t\t\twhile(list[j].value > list[Math.floor((j-1)/2)].value){\n// \t\t\t\tvar temp = list[j];\n// \t\t\t\tlist[j] = list[Math.floor((j-1)/2)];\n// \t\t\t\tlist[Math.floor((j-1)/2)] = temp;\n// \t\t\t}\n// \t\t}\n// \t}\n// }\n// heapsort = (list) => {\n// \theapify(list);\n// \tvar length = list.length;\n// \tfor(var i = length - 1; i>=0; i--){\n// \t\t//swap value of first index with last index\n// \t\tvar temp = list[0];\n// \t\tlist[0] = list[i];\n// \t\tlist[i] = temp;\n// \t\t//maintaining heap property, after each swap \n// \t\tvar j = 0;\n// \t\tvar index = 0;\n// \t\twhile(true){\n// \t\t\tindex = 2*i+1;\n// \t\t\t//if left child is smaller than right child, point index to right child\n// \t\t\tif(index < (i - 1) && list[index].value < list[index + 1].value){\n// \t\t\t\tindex++;\n// \t\t\t}\n// \t\t\t//if parent is smaller than child, swap them with child having higher value\n// \t\t\tif(index < i && list[j].value < list[index].value){\n// \t\t\t\ttemp = list[j];\n// \t\t\t\tlist[j] = list[index];\n// \t\t\t\tlist[index] = temp;\n// \t\t\t}\n// \t\t\tj = index;\n// \t\t\tif(index >= i){\n// \t\t\t\tbreak;\n// \t\t\t}\n// \t\t}\n// \t}\n// }\n// verify = (list) => {\n//     const length = list.lenght;\n//     for(var i = 0; i<list.length; i++){\n//       var left = i * 2 + 1;\n//       var right = i * 2 + 2;\n//       if(left < length && list[left] > list[i]){\n//         return false;\n//       }\n//       if(right < length && list[right] > list[i]){\n//         return false;\n//       }\n//     }\n//     return true;\n// }\npartition = (list, low, high) => {\n  var pivot = list[high];\n  var i = low - 1; //index of smaller element\n\n  for (var j = low; j <= high - 1; j++) {\n    //if current element is smaller than or equal to pivot \n    if (list[j].value <= pivot.value) {\n      i++; //swap list[i] and list[j]\n\n      var temp = list[i];\n      list[i] = list[j];\n      list[j] = temp;\n    }\n  }\n\n  temp = list[i + 1];\n  list[i + 1] = list[high];\n  list[high] = temp;\n  return i + 1;\n};\n\nexport default quicksort = (list, low, high) => {\n  var size = high - low + 1; //create auxiliary stack\n\n  var stack = new Array(size); //initialize top of the stack\n\n  var top = -1; //push initial values of high and low to the stack\n\n  stack[++top] = low;\n  stack[++top] = high;\n\n  while (top >= 0) {\n    high = stack[top--];\n    low = stack[top--]; //set pivot element in its correct position, in sorted array\n\n    var p = this.partition(list, low, high); //if there are elements on left side of pivot, push left side to stack\n\n    if (p - 1 > low) {\n      stack[++top] = low;\n      stack[++top] = p - 1;\n    } //if there are elements on right side of pivot, push right side to stack\n\n\n    if (p + 1 > high) {\n      stack[++top] = p + 1;\n      stack[++top] = high;\n    }\n  }\n\n  return stack;\n};","map":{"version":3,"sources":["/Users/diego_ramirezs/Documents/sorting/visualizer/src/test.js"],"names":["partition","list","low","high","pivot","i","j","value","temp","quicksort","size","stack","Array","top","p"],"mappings":"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","sourcesContent":["// mergesort = (list) => {\n// \tvar m = 1;\n// \tvar right;\n// \tvar left;\n// \tvar sorted; \n// \tvar maxIndex;\n// \tvar auxArray; \n\n// \twhile (m < n){\n// \t\tvar i = 0;\n// \t\twhile(i< n - m){\n// \t\t\tleft = list.slice(i, i+m-1);\n// \t\t\tmaxIndex = Math.min(i+2*m-1, n-1)\n// \t\t\tright = list.slice(i+m, maxIndex);\n// \t\t\tsorted = [];\n// \t\t\tauxArray = [];\n\t\t\t\n\n// \t\t\twhile(left.right && right.length){\n// \t\t\t\tif(left[0].value <= right[0].value){\n// \t\t\t\t\tsorted.push(left.shift());\n// \t\t\t\t}else{\n// \t\t\t\t\tsorted.push(right.shift());\n// \t\t\t\t}\n// \t\t\t}\n\n// \t\t\twhile(left.length){\n// \t\t\t\tsorted.push(left.shift());\n// \t\t\t}\n\n// \t\t\twhile(right.length){\n// \t\t\t\tsorted.push(right.shift());\n// \t\t\t}\n// \t\t\tvar x = list.slice(0, i);\n// \t\t\tvar y = list.slice(maxIndex, list.length);\n// \t\t\tauxArray = x.concat(sorted, y);\n// \t\t\ti = i + 2*m\n// \t\t}\n// \t\tm = m * 2;\n// \t}\n// \tthis.setState({array: auxArray});\n// }\n\n\n\n// heapify = (list) => {\n// \tvar j; \n// \tfor (var i = 0; i<list.length; i++){\n// \t\t//if child is bigger than parent\n// \t\tif(list[i].value > list[Math.floor((i-1)/2)].value){\n// \t\t\tj = i;\n\n// \t\t\t//swap child and parent until parent is smaller\n// \t\t\twhile(list[j].value > list[Math.floor((j-1)/2)].value){\n// \t\t\t\tvar temp = list[j];\n// \t\t\t\tlist[j] = list[Math.floor((j-1)/2)];\n// \t\t\t\tlist[Math.floor((j-1)/2)] = temp;\n// \t\t\t}\n// \t\t}\n// \t}\n// }\n\n\n// heapsort = (list) => {\n// \theapify(list);\n// \tvar length = list.length;\n\n// \tfor(var i = length - 1; i>=0; i--){\n// \t\t//swap value of first index with last index\n// \t\tvar temp = list[0];\n// \t\tlist[0] = list[i];\n// \t\tlist[i] = temp;\n\n// \t\t//maintaining heap property, after each swap \n// \t\tvar j = 0;\n// \t\tvar index = 0;\n\n// \t\twhile(true){\n// \t\t\tindex = 2*i+1;\n\n// \t\t\t//if left child is smaller than right child, point index to right child\n// \t\t\tif(index < (i - 1) && list[index].value < list[index + 1].value){\n// \t\t\t\tindex++;\n// \t\t\t}\n\n// \t\t\t//if parent is smaller than child, swap them with child having higher value\n// \t\t\tif(index < i && list[j].value < list[index].value){\n// \t\t\t\ttemp = list[j];\n// \t\t\t\tlist[j] = list[index];\n// \t\t\t\tlist[index] = temp;\n// \t\t\t}\n\n// \t\t\tj = index;\n// \t\t\tif(index >= i){\n// \t\t\t\tbreak;\n// \t\t\t}\n// \t\t}\n// \t}\n// }\n\n// verify = (list) => {\n//     const length = list.lenght;\n//     for(var i = 0; i<list.length; i++){\n//       var left = i * 2 + 1;\n//       var right = i * 2 + 2;\n//       if(left < length && list[left] > list[i]){\n//         return false;\n//       }\n\n//       if(right < length && list[right] > list[i]){\n//         return false;\n//       }\n//     }\n//     return true;\n// }\n\n\n\n\n\npartition = (list, low, high) => {\n\tvar pivot = list[high];\n\tvar i = (low - 1);\n\t//index of smaller element\n\tfor(var j=low; j<=high-1; j++){\n\t\t//if current element is smaller than or equal to pivot \n\t\tif(list[j].value <= pivot.value){\n\t\t\ti++;\n\n\t\t\t//swap list[i] and list[j]\n\t\t\tvar temp = list[i];\n\t\t\tlist[i] = list[j];\n\t\t\tlist[j] = temp;\n\t\t}\n\t}\n\n\ttemp = list[i+1];\n\tlist[i+1] = list[high];\n\tlist[high] = temp;\n\n\treturn i+1;\n}\n\n\nexport default quicksort = (list, low, high) => {\n\tvar size = high - low + 1;\n\n\t//create auxiliary stack\n\tvar stack = new Array(size);\n\n\t//initialize top of the stack\n\tvar top = -1;\n\n\t//push initial values of high and low to the stack\n\tstack[++top] = low;\n\tstack[++top] = high;\n\n\twhile(top >= 0){\n\t\thigh = stack[top--];\n\t\tlow = stack[top--];\n\n\t\t//set pivot element in its correct position, in sorted array\n\t\tvar p = this.partition(list, low, high);\n\n\t\t//if there are elements on left side of pivot, push left side to stack\n\t\tif (p - 1> low){\n\t\t\tstack[++top] = low;\n\t\t\tstack[++top] = p - 1;\n\t\t}\n\n\t\t//if there are elements on right side of pivot, push right side to stack\n\t\tif (p+1 > high){\n\t\t\tstack[++top] = p + 1;\n\t\t\tstack[++top] = high;\n\t\t}\n\t}\n\treturn stack;\n}\n\n\n\n\n\n\n\n\n\n"]},"metadata":{},"sourceType":"module"}